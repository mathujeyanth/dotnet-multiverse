@attribute [Route(PageUrl)]
@rendermode InteractiveAuto

@using System.IO
@using DotnetMultiverse.Shared.SoundConverter.AudioFormats
@using FluentValidation

@inject IJSRuntime JsRuntime
@inject AudioHandler AudioHandler

<PageTitle>Sound Converter</PageTitle>

<MudGrid>
    <MudItem xs="12" sm="7">
        <MudPaper Class="pa-4">
            <MudForm Model="@_model"
                     @bind-IsValid="_isValid"
                     @bind-IsTouched="_isTouched"
                     Validation="@_validationRules.ValidateValue">
                <MudStack Spacing="3">
                    <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                                   @ref="@_fileUpload"
                                   @bind-Files="_model.Files"
                                   For="@(() => _model.Files!)"
                                   Accept=".mp3"
                                   AppendMultipleFiles="true"
                                   Hidden="@false"
                                   InputClass="absolute mud-width-full mud-height-full overflow-hidden z-10"
                                   InputStyle="opacity:0"
                                   ErrorText="@string.Empty"
                                   MaximumFileCount="20"
                                   tabindex="-1"
                                   @ondrop="@ClearDragClass"
                                   @ondragenter="@SetDragClass"
                                   @ondragleave="@ClearDragClass"
                                   @ondragend="@ClearDragClass"
                                   Style="width: 100%;">
                        <ActivatorContent>
                            <MudPaper Height="300px"
                                      Outlined="true"
                                      Class="@_dragClass">
                                <MudText Typo="Typo.h6" Align="Align.Center">
                                    Drag and drop files here or click
                                </MudText>
                                @foreach (var file in _model.Files?.Select(file => file.Name) ?? [])
                                {
                                    <MudChip T="string" Color="Color.Dark" Text="@file"/>
                                }
                            </MudPaper>
                        </ActivatorContent>
                    </MudFileUpload>
                    <MudStack Spacing="2" Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start" StretchItems="StretchItems.None">
                        <MudButton Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.AttachFile"
                                   OnClick="@OpenFilePickerAsync"
                                   Variant="Variant.Filled">
                            Select file
                        </MudButton>
                        <MudButton Color="Color.Error"
                                   StartIcon="@Icons.Material.Filled.Delete"
                                   Disabled="@(_model.Files is null || !_model.Files.Any())"
                                   OnClick="@ClearAsync"
                                   Variant="Variant.Filled">
                            Clear
                        </MudButton>
                        <MudSpacer/>
                        <MudButton Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.DoubleArrow"
                                   Disabled="@(!_isValid || !_isTouched || _model.Files is null || !_model.Files.Any())"
                                   OnClick="@Convert"
                                   Variant="Variant.Filled">
                            Convert
                        </MudButton>
                    </MudStack>
                </MudStack>
            </MudForm>
        </MudPaper>
    </MudItem>
    <MudItem xs="12" sm="5">
        <MudPaper Class="pa-4 mud-height-full">
            @if (_progressTableRows.Count == 0)
            {
                <MudTable 
                    Items="Enumerable.Range(0, 5)"
                    Hover="true" Dense="true" Outlined="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        <MudTh>File Name</MudTh>
                        <MudTh>Progress</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="File Name">
                            <MudSkeleton/>
                        </MudTd>
                        <MudTd DataLabel="Progress">
                            <MudSkeleton/>
                        </MudTd>
                        <MudTd DataLabel="Download">
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }
            else
            {
                <MudTable 
                    Items="_progressTableRows"
                    Loading="@(_progressTableRows.Any(x => !x.IsFinished))"
                    Hover="true" Dense="true" Outlined="true" Breakpoint="Breakpoint.None" RowsPerPage="@MaxUploadFiles">
                    <HeaderContent>
                        <MudTh>File Name</MudTh>
                        <MudTh>Progress</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="File Name">
                            @context.FileName
                        </MudTd>
                        <MudTd DataLabel="Progress">
                            <MudProgressLinear Color="Color.Primary" Striped="@(!context.IsFinished)" Value="@context.Progress" Min="0" Max="1" Size="Size.Large">
                                <MudText>
                                    @((int)(context.Progress * 100))%
                                </MudText>
                            </MudProgressLinear>
                        </MudTd>
                        <MudTd DataLabel="Download">
                            <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Primary" Disabled="@(!context.IsFinished)" OnClick="@(()=>  DownloadFileFromStream(context.FileName, context.OutputAudio!))"/>
                        </MudTd>
                    </RowTemplate>
                    <PagerContent>
                        <MudTablePager HorizontalAlignment="HorizontalAlignment.Start" HideRowsPerPage="true"/>
                    </PagerContent>
                </MudTable>

            }
        </MudPaper>
    </MudItem>
</MudGrid>

<script>
    window.jsDownloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private class ProgressTableRow
    {
        public required string From { get; set; }
        public required string To { get; set; }
        public required string FileName { get; init; }
        public IProgress<Double> ProgressHandler { get; set; } = null!;
        public double Progress { get; set; }
        public bool IsFinished { get; set; }
        public required IBrowserFile BrowserFile { get; init; }
        public IAudio? OutputAudio { get; set; }
    }

    private readonly IList<ProgressTableRow> _progressTableRows = new List<ProgressTableRow>(); 
    
    public const string PageUrl = "soundConverter";
    const long MaxFileSize = 2L * 1024L * 1024L * 1024L; // 2GB

    public class Model
    {
        public IReadOnlyList<IBrowserFile>? Files { get; set; } = new List<IBrowserFile>();
    }

    private readonly Model _model = new();
    private readonly ModelFluentValidator _validationRules = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private bool _isValid;
    private bool _isTouched;
    private const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string _dragClass = DefaultDragClass;
    private const int MaxUploadFiles = 5;

    private async Task Convert()
    {
        if (!_isValid ||_model.Files is null) throw new Exception();
        var files = _model.Files.ToArray();
        _model.Files = new List<IBrowserFile>();
        // Design Revision: Potentially use a queuing mechanism, to allow only converting three at a time, and to avoid running too many concurrent converts.
        var tempProgressTableRows = new List<ProgressTableRow>();
        foreach (var file in files)
        {
            var progressTableRow = new ProgressTableRow
            {
                From = "mp3",
                To = "ogg",
                FileName = file.Name,
                OutputAudio = null,
                BrowserFile = file
            };
            _progressTableRows.Add(progressTableRow);
            tempProgressTableRows.Add(progressTableRow);
        }

        foreach (var progressTableRow in tempProgressTableRows)
        {
            var inputAudio = await Task.Run(() => AudioHandler.ValidateAndCreateAudio(progressTableRow.BrowserFile));
            progressTableRow.ProgressHandler = new Progress<double>(x =>
            {
                progressTableRow.Progress = x;
                StateHasChanged();
            });

            progressTableRow.OutputAudio = await Task.Run(() => AudioHandler.ToOgg(inputAudio, progressTableRow.ProgressHandler));

            progressTableRow.Progress = 1;
            progressTableRow.IsFinished = true;
            StateHasChanged();
        }
    }

    private void SetDragClass()
        => _dragClass = $"{DefaultDragClass} mud-border-primary";

    private void ClearDragClass()
        => _dragClass = DefaultDragClass;

    private Task OpenFilePickerAsync()
        => _fileUpload?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private Task ClearAsync()
        => _fileUpload?.ClearAsync() ?? Task.CompletedTask;

    public class ModelFluentValidator : AbstractValidator<Model>
    {
        public ModelFluentValidator()
        {
            RuleFor(x => x.Files)
                .NotEmpty()
                .WithMessage("There must be at least 1 file.");
            RuleFor(x => x.Files)
                .Must(x => x?.Count <= MaxUploadFiles)
                .WithMessage($"Maximum of {MaxUploadFiles} files can be uploaded.");
            
            var acceptedTypes = new List<string> { "audio/mpeg", "audio/ogg", "audio/wav" };
            RuleForEach(x => x.Files)
                .Must(x => acceptedTypes.Contains(x.ContentType))
                .WithMessage("Not accepted type.");
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<Model>.CreateWithOptions((Model)model, x => x.IncludeProperties(propertyName)));
            return result.IsValid ? Array.Empty<string>() : result.Errors.Select(e => e.ErrorMessage);
        };
    }

    private async Task DownloadFileFromStream(string fileName, IAudio outputAudio)
    {
        outputAudio.AudioStream.Seek(0, SeekOrigin.Begin);
        using var streamRef = new DotNetStreamReference(stream: outputAudio.AudioStream);
        var newFileName = $"{Path.GetFileNameWithoutExtension(fileName)} - converted.{outputAudio.Extension}";
        await JsRuntime.InvokeVoidAsync("jsDownloadFileFromStream", newFileName, streamRef);
    }
}
