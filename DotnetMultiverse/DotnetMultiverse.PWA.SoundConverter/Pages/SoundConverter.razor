@attribute [Route(PageUrl)]
@rendermode InteractiveWebAssembly
@implements IAsyncDisposable

@using System.Collections.Concurrent
@using System.IO
@using System.Threading
@using DotnetMultiverse.Shared.SoundConverter
@using DotnetMultiverse.Shared.SoundConverter.AudioFormats
@using FluentValidation

@inject IJSRuntime JsRuntime
@inject AudioHandler AudioHandler

<PageTitle>Sound Converter</PageTitle>

<MudGrid>
    <MudItem xs="12" sm="7">
        <MudPaper Class="pa-4">
            <MudForm Model="@_model"
                     @bind-IsValid="_isValid"
                     @bind-IsTouched="_isTouched"
                     Validation="@_validationRules.ValidateValue">
                <MudStack Spacing="3">
                    <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                                   @ref="@_fileUpload"
                                   @bind-Files="_model.Files"
                                   For="@(() => _model.Files!)"
                                   Accept=".mp3"
                                   AppendMultipleFiles="true"
                                   Hidden="@false"
                                   InputClass="absolute mud-width-full mud-height-full overflow-hidden z-10"
                                   InputStyle="opacity:0"
                                   ErrorText="@string.Empty"
                                   MaximumFileCount="20"
                                   tabindex="-1"
                                   @ondrop="@ClearDragClass"
                                   @ondragenter="@SetDragClass"
                                   @ondragleave="@ClearDragClass"
                                   @ondragend="@ClearDragClass"
                                   Style="width: 100%;">
                        <ActivatorContent>
                            <MudPaper Height="300px"
                                      Outlined="true"
                                      Class="@_dragClass">
                                <MudText Typo="Typo.h6" Align="Align.Center">
                                    Drag and drop files here or click
                                </MudText>
                                @foreach (var file in _model.Files?.Select(file => file.Name) ?? [])
                                {
                                    <MudChip T="string" Color="Color.Dark" Text="@file"/>
                                }
                            </MudPaper>
                        </ActivatorContent>
                    </MudFileUpload>
                    <MudStack Spacing="2" Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start" StretchItems="StretchItems.None">
                        <MudButton Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.AttachFile"
                                   OnClick="@OpenFilePickerAsync"
                                   Variant="Variant.Filled">
                            Select file
                        </MudButton>
                        <MudButton Color="Color.Error"
                                   StartIcon="@Icons.Material.Filled.Delete"
                                   Disabled="@(_model.Files is null || !_model.Files.Any())"
                                   OnClick="@ClearAsync"
                                   Variant="Variant.Filled">
                            Clear
                        </MudButton>
                        <MudSpacer/>
                        <MudButton Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.DoubleArrow"
                                   Disabled="@(!_isValid || !_isTouched || _model.Files is null || !_model.Files.Any())"
                                   OnClick="@Convert"
                                   Variant="Variant.Filled">
                            Convert
                        </MudButton>
                    </MudStack>
                </MudStack>
            </MudForm>
        </MudPaper>
    </MudItem>
    <MudItem xs="12" sm="5">
        <MudPaper Class="pa-4 mud-height-full">
            @if (_guidToProgress.Count == 0)
            {
                <MudTable 
                    Items="Enumerable.Range(0, 5)"
                    Hover="true" Dense="true" Outlined="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        <MudTh>File Name</MudTh>
                        <MudTh>Progress</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="File Name">
                            <MudSkeleton/>
                        </MudTd>
                        <MudTd DataLabel="Progress">
                            <MudSkeleton/>
                        </MudTd>
                        <MudTd DataLabel="Download">
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }
            else
            {
                <MudTable 
                    Items="_guidToProgress.ToList()"
                    Loading="@(_guidToProgress.Values.Any(x => !x.IsFinished))"
                    Hover="true" Dense="true" Outlined="true" Breakpoint="Breakpoint.None" RowsPerPage="@MaxUploadFiles">
                    <HeaderContent>
                        <MudTh>File Name</MudTh>
                        <MudTh>Progress</MudTh>
                        <MudTh></MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="File Name">
                            @context.Value.FileName
                        </MudTd>
                        <MudTd DataLabel="Progress">
                            <MudProgressLinear Color="Color.Primary" Striped="@(!context.Value.IsFinished)" Value="@context.Value.Progress" Min="0" Max="1" Size="Size.Large">
                                <MudText>
                                    @((int)(context.Value.Progress * 100))%
                                </MudText>
                            </MudProgressLinear>
                        </MudTd>
                        <MudTd DataLabel="Download">
                            <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Primary" Disabled="@(!context.Value.IsFinished)" OnClick="@(()=>  DownloadFileFromStream(context.Key))"/>
                        </MudTd>
                    </RowTemplate>
                    <PagerContent>
                        <MudTablePager HorizontalAlignment="HorizontalAlignment.Start" HideRowsPerPage="true"/>
                    </PagerContent>
                </MudTable>

            }
        </MudPaper>
    </MudItem>
</MudGrid>

<script>
    window.jsDownloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private class ProgressTableRow
    {
        public required Guid Guid { get; init; } 
        public required string From { get; set; }
        public required string To { get; set; }
        public required string FileName { get; init; }
        // public IProgress<double> ProgressHandler { get; set; } = null!;
        public double Progress { get; set; }
        public bool IsFinished { get; set; }
        public IAudio? OutputAudio { get; set; }
    }

    private readonly IDictionary<Guid, ProgressTableRow> _guidToProgress = new Dictionary<Guid, ProgressTableRow>(); 
    
    public const string PageUrl = "";
    const long MaxFileSize = 2L * 1024L * 1024L * 1024L; // 2GB

    public class Model
    {
        public IReadOnlyList<IBrowserFile>? Files { get; set; } = new List<IBrowserFile>();
    }

    private readonly Model _model = new();
    private readonly ModelFluentValidator _validationRules = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private bool _isValid;
    private bool _isTouched;
    private const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string _dragClass = DefaultDragClass;
    private const int MaxUploadFiles = 5;
    
    private class ConversionScheduler(AudioHandler audioHandler)
    {
        public event Func<Task> OnChangeAsync = null!;
        private void NotifyStateChanged() => OnChangeAsync.Invoke();
        private Thread? _thread;
        
        private readonly ConcurrentQueue<(ProgressTableRow progressTableRow, IAudio audio)> _concurrentQueue = new();

        public void AddToQueue(ProgressTableRow progressTableRow, IAudio audio)
        {
            _concurrentQueue.Enqueue((progressTableRow, audio));
        }

        private async Task Converter()
        {
            Console.WriteLine("In thread");
            while (!_concurrentQueue.IsEmpty)
            {
                if (!_concurrentQueue.TryDequeue(out var result))
                {
                    throw new Exception();
                }

                var guid = result.progressTableRow.Guid;
                Console.WriteLine(guid);
                var inputAudio = result.audio;
                var progressHandler = new Progress<double>(progress =>
                {
                    Console.WriteLine($"Got update for {result.progressTableRow.Guid} with {progress}");
                    result.progressTableRow.Progress = progress;
                    NotifyStateChanged();
                });
                    
                Console.WriteLine($"{guid} before");
                result.progressTableRow.OutputAudio = await audioHandler.ToOgg(inputAudio, progressHandler);
                Console.WriteLine($"{guid} after convert");

                result.progressTableRow.Progress = 1;
                result.progressTableRow.IsFinished = true;
                NotifyStateChanged();
            }
        }

        public void StartConverting()
        {
            
            Console.WriteLine("Before check");
            if (_thread is not null && _thread.IsAlive) return;
            Console.WriteLine("Before thread");
            _thread = new Thread(async void () => await Converter());
            _thread.Start();
        }
    }

    private ConversionScheduler _conversionScheduler = null!;

    private async Task Convert()
    {
        if (!_isValid ||_model.Files is null) throw new Exception();
        var files = _model.Files.ToArray();
        _model.Files = new List<IBrowserFile>();
        // Design Revision: Potentially use a queuing mechanism, to allow only converting three at a time, and to avoid running too many concurrent converts.
        var guidToFile = new Dictionary<Guid, IBrowserFile>(); 
        foreach (var file in files)
        {
            var guid = Guid.NewGuid();
            var progressTableRow = new ProgressTableRow
            {
                Guid = Guid.NewGuid(),
                From = "mp3",
                To = "ogg",
                FileName = file.Name,
                OutputAudio = null
            };
            _guidToProgress[guid] = progressTableRow;
            guidToFile[guid] = file;
        }
        

        foreach (var (key, file) in guidToFile)
        {
            var progressTableRow = _guidToProgress[key];
            var inputAudio = await AudioHandler.ValidateAndCreateAudio(file);
        
            Console.WriteLine("before");
            _conversionScheduler.AddToQueue(progressTableRow, inputAudio);
            Console.WriteLine("finished");
            
            guidToFile.Remove(key);
        }
        _conversionScheduler.StartConverting();
    }
    
    private void SetDragClass()
        => _dragClass = $"{DefaultDragClass} mud-border-primary";

    private void ClearDragClass()
        => _dragClass = DefaultDragClass;

    private Task OpenFilePickerAsync()
        => _fileUpload?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private Task ClearAsync()
        => _fileUpload?.ClearAsync() ?? Task.CompletedTask;

    public class ModelFluentValidator : AbstractValidator<Model>
    {
        public ModelFluentValidator()
        {
            RuleFor(x => x.Files)
                .NotEmpty()
                .WithMessage("There must be at least 1 file.");
            RuleFor(x => x.Files)
                .Must(x => x?.Count <= MaxUploadFiles)
                .WithMessage($"Maximum of {MaxUploadFiles} files can be uploaded.");
            
            var acceptedTypes = new List<string> { "audio/mpeg", "audio/ogg", "audio/wav" };
            RuleForEach(x => x.Files)
                .Must(x => acceptedTypes.Contains(x.ContentType))
                .WithMessage("Not accepted type.");
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<Model>.CreateWithOptions((Model)model, x => x.IncludeProperties(propertyName)));
            return result.IsValid ? Array.Empty<string>() : result.Errors.Select(e => e.ErrorMessage);
        };
    }

    private async Task DownloadFileFromStream(Guid guid)
    {
        var file = _guidToProgress[guid];
        var fileName = file.FileName;
        using var outputAudio = file.OutputAudio!;
        outputAudio.AudioStream.Seek(0, SeekOrigin.Begin);
        using var streamRef = new DotNetStreamReference(stream: outputAudio.AudioStream);
        var newFileName = $"{Path.GetFileNameWithoutExtension(fileName)} - converted.{outputAudio.Extension}";
        await JsRuntime.InvokeVoidAsync("jsDownloadFileFromStream", newFileName, streamRef);
    }

    protected override Task OnInitializedAsync()
    {
        _conversionScheduler = new ConversionScheduler(AudioHandler);
        _conversionScheduler.OnChangeAsync += Refresh;
        return base.OnInitializedAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_fileUpload != null) await _fileUpload.DisposeAsync();
        _conversionScheduler.OnChangeAsync -= Refresh;
    }
    
    async Task Refresh()
    {
        await InvokeAsync(StateHasChanged);
    }
}
